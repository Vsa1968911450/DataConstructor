哈希表 基于数组实现  数据没有顺序 不能以一种固定的方式来遍历元素  key不允许重复
哈希函数 字符串转成一个下标值  单次转化成大数字，在进行哈希化的代码放在一个函数中
幂的联乘（数组下标太大）  相加（数组下标太小）
哈希化   压缩方案  下标有可能会重复引发冲突 冲突不可避免 我们只能解决冲突
取余操作  大数字转化成数组范围内下标
哈希表 数据插入到这个数组 对整个结构的封装
链地址法 拉链法 每一个位置都存储一个链表或者数组 将元素放到里面  比如 一个数 除以10 看余数存放
开放地址法 寻找空白的位置来放置冲突的数据项
方法：
线性探测  线性寻找空白的单元格 遇到空白的位置就停止就说明没有 问题 聚集 ：一连串的填充单元 会影响哈希表的性能  为了放一个元素 要连续查找多个元素  步长为1  +1 +1 
二次探测  步长为x+1的平方 x+2的平方 （1.4.9.16）O(N平方)
再哈希法  关键字用一个哈希函数 在做一个哈希化 第二次哈希化的结果作为步长  不能和原来一样 不能输出为0
步长  stepSize = constant - (key % constant)  constant 是质数 且小于数组长度
优秀的哈希函数 速度 尽可能减少乘法除法 下标值均匀分布

快速计算 霍纳法则 a1 x （1）  a2 x（2） 规定x的大小 常量 a1 就是规定数字的在规则里的大小  O(N)

java中 哈希表采用连地址法
hashmap 初始长度是16 每次自动扩展 长度必须是2的次幂  为了提高效率 采用位运算的方式
index = hashcode（key）&（Length - 1）
容量使用质数